{"version":3,"sources":["Model/Tests/EdgeWithVerticesWithSubscriptsUnitTests.spec.ts"],"names":[],"mappings":"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","file":"Model/Tests/EdgeWithVerticesWithSubscriptsUnitTests.spec.js","sourcesContent":["import 'mocha';\r\nimport * as lodash from 'lodash';\r\nimport { expect } from 'chai';\r\nimport { VerticeWithSubscript, EdgeWithVerticesWithSubscripts } from '../';\r\n\r\ndescribe.only('EdgeWithVerticesWithSubscripts', () => {\r\n    let emptyValuesArr: VerticeWithSubscript[] = [undefined, null];\r\n    let truthValues = [false, true];\r\n\r\n    describe('ToCanonicalForm', () => {\r\n        truthValues.forEach((truthVal) => {\r\n            describe('empty values when isBackward is ' + truthVal, () => {\r\n                emptyValuesArr.forEach((firstVal) => {\r\n                    emptyValuesArr.forEach((secondVal) => {\r\n                        it('From first vertice, first vertice is ' + firstVal + ' and the second is ' + secondVal + ' - should throw error appropriately', () => {\r\n                            let edge = new EdgeWithVerticesWithSubscripts();\r\n                            edge.firstVertice = firstVal;\r\n                            edge.secondVertice = secondVal;\r\n\r\n                            let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.firstVertice) };\r\n\r\n                            expect(badFunc).to.throw('First vertice is empty');\r\n                        });\r\n\r\n                        it('From second vertice, first vertice is ' + firstVal + ' and the second is ' + secondVal + ' - should throw error appropriately', () => {\r\n                            let edge = new EdgeWithVerticesWithSubscripts();\r\n                            edge.firstVertice = firstVal;\r\n                            edge.secondVertice = secondVal;\r\n\r\n                            let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.secondVertice) };\r\n\r\n                            expect(badFunc).to.throw('First vertice is empty');\r\n                        });\r\n                    });\r\n                });\r\n\r\n                emptyValuesArr.forEach((val) => {\r\n                    it('From first vertice, first vertice is ' + val + ' - should throw error appropriately', () => {\r\n                        let edge = new EdgeWithVerticesWithSubscripts();\r\n                        edge.secondVertice = new VerticeWithSubscript();\r\n\r\n                        let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.firstVertice) };\r\n\r\n                        expect(badFunc).to.throw('First vertice is empty');\r\n                    });\r\n\r\n                    it('From second vertice, first vertice is ' + val + ' - should throw error appropriately', () => {\r\n                        let edge = new EdgeWithVerticesWithSubscripts();\r\n                        edge.secondVertice = new VerticeWithSubscript();\r\n\r\n                        let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.secondVertice) };\r\n\r\n                        expect(badFunc).to.throw('First vertice is empty');\r\n                    })\r\n                });\r\n\r\n                emptyValuesArr.forEach((val) => {\r\n                    it('From first vertice, Second vertice is ' + val + ' - should throw error appropriately', () => {\r\n                        let edge = new EdgeWithVerticesWithSubscripts();\r\n                        edge.firstVertice = new VerticeWithSubscript();\r\n\r\n                        let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.firstVertice) };\r\n\r\n                        expect(badFunc).to.throw('second vertice is empty');\r\n                    });\r\n\r\n                    it('From second vertice, Second vertice is ' + val + ' - should throw error appropriately', () => {\r\n                        let edge = new EdgeWithVerticesWithSubscripts();\r\n                        edge.firstVertice = new VerticeWithSubscript();\r\n\r\n                        let badFunc = function () { let canonicalForm = edge.ToCanonicalForm(truthVal, edge.secondVertice) };\r\n\r\n                        expect(badFunc).to.throw('second vertice is empty');\r\n                    });\r\n                });\r\n            });\r\n        });\r\n\r\n        describe('Correct edge', () => {\r\n            it('from first vertice, backwards if false - should return correct result', () => {\r\n                let edge = new EdgeWithVerticesWithSubscripts({ id: '0', label: 'a' });\r\n                edge.firstVertice = new VerticeWithSubscript({ Id: '0', label: 'X' });\r\n                edge.secondVertice = new VerticeWithSubscript({ Id: '1', label: 'Y' });\r\n\r\n                let canonicalForm = edge.ToCanonicalForm(false, edge.firstVertice);\r\n\r\n                expect(canonicalForm).to.be.deep.equal(['0', '1', 'X', 'a', 'Y']);\r\n            });\r\n\r\n            it('from first vertice, isbackwards is true - should return correct result', () => {\r\n                let edge = new EdgeWithVerticesWithSubscripts({ id: '0', label: 'a' });\r\n                edge.firstVertice = new VerticeWithSubscript({ Id: '0', label: 'X' });\r\n                edge.secondVertice = new VerticeWithSubscript({ Id: '1', label: 'Y' });\r\n\r\n                let canonicalForm = edge.ToCanonicalForm(true, edge.firstVertice);\r\n\r\n                expect(canonicalForm).to.be.deep.equal(['1', '0', 'Y', 'a', 'X']);\r\n            });\r\n\r\n            it('from second vertice, backwards if false - should return correct result', () => {\r\n                let edge = new EdgeWithVerticesWithSubscripts({ id: '0', label: 'a' });\r\n                edge.firstVertice = new VerticeWithSubscript({ Id: '0', label: 'X' });\r\n                edge.secondVertice = new VerticeWithSubscript({ Id: '1', label: 'Y' });\r\n\r\n                let canonicalForm = edge.ToCanonicalForm(false, edge.secondVertice);\r\n\r\n                expect(canonicalForm).to.be.deep.equal(['1', '0', 'Y', 'a', 'X']);\r\n            });\r\n\r\n            it('from second vertice, isbackwards is true - should return correct result', () => {\r\n                let edge = new EdgeWithVerticesWithSubscripts({ id: '0', label: 'a' });\r\n                edge.firstVertice = new VerticeWithSubscript({ Id: '0', label: 'X' });\r\n                edge.secondVertice = new VerticeWithSubscript({ Id: '1', label: 'Y' });\r\n\r\n                let canonicalForm = edge.ToCanonicalForm(true, edge.secondVertice);\r\n\r\n                expect(canonicalForm).to.be.deep.equal(['0', '1', 'X', 'a', 'Y']);\r\n            });\r\n        });\r\n    });\r\n});"],"sourceRoot":"/source/"}