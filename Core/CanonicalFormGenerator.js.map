{"version":3,"sources":["Core/CanonicalFormGenerator.ts"],"names":[],"mappings":"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","file":"Core/CanonicalFormGenerator.js","sourcesContent":["import { Graph, Vertice, Edge, VerticeWithSubscript, EdgeWithVerticesWithSubscripts } from '../Model';\r\nimport * as lodash from 'lodash';\r\n\r\nexport class CanonicalFormGenerator {\r\n    private vertices: VerticeWithSubscript[];\r\n    private edges: EdgeWithVerticesWithSubscripts[];\r\n\r\n    constructor(graph: Graph) {\r\n        if (lodash.isEmpty(graph.V)) {\r\n            throw 'There are no edges in the graph';\r\n        }\r\n\r\n        this.vertices = this.generateVerticesWithSubscripts(graph.V);\r\n        this.edges = this.generateEdgesWithVerticesWithSubscripts(this.vertices, graph.E);\r\n    }\r\n\r\n    public GetCanonicalForm(): string[][] {\r\n        let edgeCanonicalForms: string[][][] = this.getAllCanonicalForms(this.vertices);\r\n        let minimalLabel = this.findMinimalCanonicalForm(edgeCanonicalForms);\r\n        return minimalLabel;\r\n    }\r\n\r\n    private getAllCanonicalForms(vertices: VerticeWithSubscript[]): string[][][] {\r\n        return lodash.map(vertices, (vertice) => {\r\n            return this.getCanonicalFormStatringWithVertice(vertice);\r\n        });\r\n    }\r\n\r\n    private getCanonicalFormStatringWithVertice(startingVertice: VerticeWithSubscript): string[][] {\r\n        let finalEdges: string[][] = [];\r\n\r\n        let clonedVertices = lodash.clone(this.vertices);\r\n        let clonedEdges = lodash.clone(this.edges);\r\n\r\n        let currentWithSubscript = this.findVerticeById(clonedVertices, startingVertice);\r\n        currentWithSubscript.Subscript = 0;\r\n\r\n        do {\r\n            let connectedEdges = this.getAllEdgesConnectedToAVertice(clonedEdges, currentWithSubscript);\r\n\r\n            if (lodash.isEmpty(connectedEdges)) {\r\n                currentWithSubscript = this.decrementVertice(currentWithSubscript, clonedVertices);\r\n                continue;\r\n            }\r\n\r\n            let notVisitedConnectedEdges = this.filterEdgesToNotVisitedVertices(clonedVertices, currentWithSubscript, connectedEdges);\r\n\r\n            if (lodash.isEmpty(notVisitedConnectedEdges)) {\r\n                let backwardEdges = this.generateBackwardEdged(connectedEdges, notVisitedConnectedEdges);\r\n                let backwardEdgesCanonicalForms = this.transformEdgesToCanonicalForms(backwardEdges, currentWithSubscript, true);\r\n                finalEdges.push.apply(finalEdges, backwardEdgesCanonicalForms);\r\n                lodash.forEach(backwardEdges, (edge) => { edge.visited = true; });\r\n\r\n                currentWithSubscript = this.decrementVertice(currentWithSubscript, clonedVertices);\r\n                continue;\r\n            }\r\n\r\n            let minimalEdge = this.findMinimalEdgeByLabel(notVisitedConnectedEdges);\r\n            minimalEdge.visited = true;\r\n            finalEdges.push(minimalEdge.ToCanonicalForm(currentWithSubscript));\r\n\r\n            let nextVertice = this.findVerticeWithSubscriptOnTheOtherSideOfTheEdge(minimalEdge, currentWithSubscript);\r\n            if (nextVertice.Subscript < 0) {\r\n                nextVertice.Subscript = currentWithSubscript.Subscript + 1;                \r\n            }\r\n            currentWithSubscript = nextVertice;\r\n        } while (this.notVisitedVerticesExist(clonedVertices));\r\n\r\n        return finalEdges;\r\n    }\r\n\r\n    private findVerticeById(vertices: VerticeWithSubscript[], oldVertice: Vertice) {\r\n        return lodash.find(vertices, (newVertice: VerticeWithSubscript) => { return newVertice.Id == oldVertice.Id })\r\n    }\r\n\r\n    private findMinimalEdgeByLabel(edges: EdgeWithVerticesWithSubscripts[]) {\r\n        let notVisitedEdges = lodash.filter(edges, (edge) => { return !edge.visited });\r\n        return lodash.minBy(notVisitedEdges, (edge) => { return edge.label })\r\n    }\r\n\r\n    private findVerticeWithSubscriptOnTheOtherSideOfTheEdge(edge: EdgeWithVerticesWithSubscripts, firstVertice: VerticeWithSubscript) {\r\n        let secondVertice: VerticeWithSubscript;\r\n        if (firstVertice == edge.firstVertice) {\r\n            secondVertice = edge.secondVertice\r\n        }\r\n\r\n        if (firstVertice.Id == edge.secondVertice.Id) {\r\n            secondVertice = edge.firstVertice;\r\n        }\r\n\r\n        return secondVertice;\r\n    }\r\n\r\n    private findMinimalCanonicalForm(edgeCanonicalForms: string[][][]): string[][] {\r\n        let minimalLabel = lodash.minBy(edgeCanonicalForms, (canonicalForm) => {\r\n            return this.concatenateStrings(canonicalForm);\r\n        });\r\n\r\n        return minimalLabel;\r\n    }\r\n\r\n    private concatenateStrings(objects: object[]): string {\r\n        return lodash.reduce(objects, (sum: string, currentString: object) => { return sum + currentString.toString() });\r\n    }\r\n\r\n    private decrementVertice(currentWithSubscript: VerticeWithSubscript, clonedVertices: VerticeWithSubscript[]) {\r\n        return lodash.find(clonedVertices, (vertice) => {\r\n            return vertice.Subscript == currentWithSubscript.Subscript - 1;\r\n        });\r\n    }\r\n\r\n    private generateEdgesWithVerticesWithSubscripts(vertices: VerticeWithSubscript[], edges: Edge[]) {\r\n        return lodash.map(edges, (edge) => {\r\n            let newEdge = new EdgeWithVerticesWithSubscripts({ id: edge.id, label: edge.label });\r\n            newEdge.firstVertice = this.findVerticeById(vertices, <VerticeWithSubscript>edge.firstVertice);\r\n            newEdge.secondVertice = this.findVerticeById(vertices, <VerticeWithSubscript>edge.secondVertice);\r\n\r\n            return newEdge;\r\n        });\r\n    }\r\n\r\n    private generateBackwardEdged(connectedEdges: EdgeWithVerticesWithSubscripts[], notVisitedConnectedEdges: EdgeWithVerticesWithSubscripts[]): EdgeWithVerticesWithSubscripts[] {\r\n        let edges = lodash.without(connectedEdges, Object.apply(notVisitedConnectedEdges));\r\n        let notVisitedEdges = lodash.filter(edges, (edge) => { return !edge.visited; });\r\n        let orderedEdges = lodash.orderBy(notVisitedEdges, (edge) => { return edge.label });\r\n\r\n        return orderedEdges;\r\n    }\r\n\r\n    private transformEdgesToCanonicalForms(edges: EdgeWithVerticesWithSubscripts[], sourceVertice: VerticeWithSubscript, isBackward: boolean): string[][] {\r\n        let canonicalForms: string[][] = lodash.map(edges, (edge: EdgeWithVerticesWithSubscripts) => {\r\n            return edge.ToCanonicalForm(sourceVertice);\r\n        });\r\n\r\n        return canonicalForms;\r\n    }\r\n\r\n    private filterEdgesToNotVisitedVertices(clonedVertices: VerticeWithSubscript[], currentWithSubscript: VerticeWithSubscript, connectedEdges: EdgeWithVerticesWithSubscripts[]) {\r\n        return lodash.filter(connectedEdges, (edge) => {\r\n            let secondVertice = this.findVerticeWithSubscriptOnTheOtherSideOfTheEdge(edge, currentWithSubscript);\r\n            return secondVertice.Subscript < 0;\r\n        });\r\n    }\r\n\r\n    private notVisitedVerticesExist(vertices: VerticeWithSubscript[]) {\r\n        return lodash.find(vertices, (vertice) => { return vertice.Subscript < 0; })\r\n    }\r\n\r\n    private getAllEdgesConnectedToAVertice(edges: EdgeWithVerticesWithSubscripts[], vertice: Vertice) {\r\n        return lodash.filter(edges, (edge) => { return edge.firstVertice.Id == vertice.Id || edge.secondVertice.Id == vertice.Id })\r\n    }\r\n\r\n    private generateVerticesWithSubscripts(vertices: Vertice[]): VerticeWithSubscript[] {\r\n        return lodash.map((vertices), (vertice) => { return new VerticeWithSubscript(vertice) });\r\n    }\r\n}"],"sourceRoot":"/source/"}